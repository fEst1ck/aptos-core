// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

//! This file implements traits for WebAuthn signatures over NIST-P256.

use crate::webauthn::webauthn_traits::WebAuthnSignature;
use crate::{
    hash::CryptoHash,
    p256::P256Signature,
    traits::*,
    webauthn::{webauthn_p256_keys::WebAuthnP256PrivateKey, WebAuthnP256PublicKey},
};
use anyhow::anyhow;
use aptos_crypto_derive::{DeserializeKey, SerializeKey};
use core::convert::TryFrom;
use serde::Serialize;
use signature::Verifier;
use std::fmt;
use webauthn_rs_core::assertion::parse_public_key_credential;
use webauthn_rs_core::proto::{COSEAlgorithm, PublicKeyCredential};

/// A WebAuthn P256 signature >= 165 bytes, <= 200 bytes
#[derive(DeserializeKey, Clone, SerializeKey)]
pub struct WebAuthnP256Signature {
    /// Challenge from [`PublicKeyCredential`](webauthn_rs_core::proto::PublicKeyCredential)
    /// Should be equal to the SHA3-256 digest of the `RawTransaction` -> 32 bytes
    pub(crate) actual_challenge: Vec<u8>,
    /// Binary concatenation of:
    /// 1. [`authenticator_data_bytes`](webauthn_rs_core::internals::AuthenticatorAssertionResponse) and
    /// 2. SHA-256 digest of [`client_data_bytes`](webauthn_rs_core::internals::AuthenticatorAssertionResponse)
    ///
    /// Note: This is compatible with signatures generated by FIDO U2F
    /// authenticators. See §6.1.2 FIDO U2F Signature Format Compatibility
    /// https://www.w3.org/TR/webauthn-2/#sctn-fido-u2f-sig-format-compat
    ///
    /// authenticator_data_bytes consists of:
    /// - rpIdHash -> 32 bytes
    /// - flags -> 1 byte
    /// - signCount -> 4 bytes
    /// - attestedCredentialData -> 0 bytes (not included in authenticatorGetAssertion §6.3.3)
    /// - extensions -> variable bytes (see [`RequestAuthenticationExtensions`](webauthn_rs_core::proto::RequestAuthenticationExtensions))
    ///
    /// Total size >= 37 + 32 = 69 bytes
    pub(crate) verification_data: Vec<u8>,
    /// P256 Signature -> 64 bytes
    pub(crate) p256_signature: P256Signature,
}

impl private::Sealed for WebAuthnP256Signature {}

impl WebAuthnP256Signature {
    /// Serialize a WebAuthnP256Signature.
    pub fn to_bytes(&self) -> Vec<u8> {
        serde_json::to_vec(self)
            .map_err(|_e| CryptoMaterialError::SerializationError)
            .unwrap()
    }

    /// Deserialize a WebAuthnP256Signature, without checking for malleability
    pub(crate) fn from_bytes_unchecked(
        bytes: &[u8],
    ) -> Result<WebAuthnP256Signature, CryptoMaterialError> {
        serde_json::from_slice(bytes).map_err(|_e| CryptoMaterialError::DeserializationError)
    }

    /// return an all-zero signature (for test only)
    #[cfg(any(test, feature = "fuzzing"))]
    pub fn dummy_signature() -> Self {
        WebAuthnP256Signature {
            actual_challenge: vec![],
            verification_data: vec![],
            p256_signature: P256Signature::from_bytes_unchecked(&[0u8; P256Signature::LENGTH])
                .unwrap(),
        }
    }
}

/////////////////////
// WebAuthn Traits //
/////////////////////

impl WebAuthnSignature for WebAuthnP256Signature {
    type VerifyingKeyMaterial = WebAuthnP256PublicKey;
    type SigningKeyMaterial = WebAuthnP256PrivateKey;

    /// Generate a [`PublicKeyCredential`](webauthn_rs_core::proto::PublicKeyCredential)
    /// from public key credential bytes and derive `WebAuthnP256Signature` from it
    fn try_from_public_key_credential_bytes(bytes: Vec<u8>) -> Result<Self, CryptoMaterialError> {
        let credential: PublicKeyCredential = serde_json::from_slice(bytes.as_slice())
            .map_err(|_e| CryptoMaterialError::DeserializationError)?;
        let (v_data, signature, actual_challenge) =
            parse_public_key_credential(&credential, COSEAlgorithm::ES256)
                .map_err(|_e| CryptoMaterialError::DeserializationError)?;

        let webauthn_p256_sig = WebAuthnP256Signature {
            actual_challenge,
            verification_data: v_data,
            p256_signature: P256Signature(signature),
        };

        // Max size check of 200 bytes
        if webauthn_p256_sig.to_bytes().len() > 200 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        Ok(webauthn_p256_sig)
    }

    /// Verifies an arbitrary challenge
    /// 1. Deep equal check to see if the provided arbitrary challenge matches the `actual_challenge`
    /// stored on the `WebAuthnP256Signature`. Once this is verified, we know that `verification_data`
    /// stores the correct challenge.
    /// 2. Uses the public key to verify the signature on `verification_data`
    #[inline]
    fn verify_arbitrary_challenge(
        &self,
        message: &[u8],
        public_key: &Self::VerifyingKeyMaterial,
    ) -> anyhow::Result<()> {
        let is_equal = self.verify_expected_challenge_from_message_matches_actual(
            message,
            self.actual_challenge.as_ref(),
        );

        // Check if expected challenge and actual challenge match. If there's no match, throw error
        if !is_equal {
            return Err(anyhow!(
                "Error: WebAuthn expected challenge did not match actual challenge"
            ));
        }

        // Verify signature against verification data
        public_key
            .0
             .0
            .verify(self.verification_data.as_slice(), &self.p256_signature.0)
            .map_err(|e| anyhow!("{}", e))
            .and(Ok(()))
    }
}

//////////////////////
// Signature Traits //
//////////////////////

impl Signature for WebAuthnP256Signature {
    type VerifyingKeyMaterial = WebAuthnP256PublicKey;
    type SigningKeyMaterial = WebAuthnP256PrivateKey;

    /// Verifies that the provided signature is valid for the provided message, going beyond the
    /// [NIST SP 800-186](https://csrc.nist.gov/publications/detail/sp/800-186/final) specification,
    /// to prevent scalar malleability as done in [BIP146](https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki).
    ///
    /// NOTE: this is a feature of the underlying P256 implementation rather than the WebAuthP256 implementation
    fn verify<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        public_key: &WebAuthnP256PublicKey,
    ) -> anyhow::Result<()> {
        Self::verify_arbitrary_msg(self, &signing_message(message)?, public_key)
    }

    /// Checks that `self` is valid for an arbitrary &[u8] `message` using `public_key`.
    /// Outside of this crate, this particular function should only be used for native signature
    /// verification in Move.
    fn verify_arbitrary_msg(
        &self,
        message: &[u8],
        public_key: &WebAuthnP256PublicKey,
    ) -> anyhow::Result<()> {
        self.verify_arbitrary_challenge(message, public_key)
    }

    fn to_bytes(&self) -> Vec<u8> {
        self.to_bytes().to_vec()
    }
}

impl Length for WebAuthnP256Signature {
    fn length(&self) -> usize {
        P256Signature::LENGTH
    }
}

impl ValidCryptoMaterial for WebAuthnP256Signature {
    fn to_bytes(&self) -> Vec<u8> {
        self.to_bytes().to_vec()
    }
}

impl std::hash::Hash for WebAuthnP256Signature {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        let encoded_signature = self.to_bytes();
        state.write(&encoded_signature);
    }
}

impl TryFrom<&[u8]> for WebAuthnP256Signature {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<WebAuthnP256Signature, CryptoMaterialError> {
        let signature = WebAuthnP256Signature::from_bytes_unchecked(bytes);
        P256Signature::try_from(
            signature
                .clone()
                .unwrap()
                .p256_signature
                .to_bytes()
                .as_ref(),
        )?;
        signature
    }
}

// Those are required by the implementation of hash above
impl PartialEq for WebAuthnP256Signature {
    fn eq(&self, other: &WebAuthnP256Signature) -> bool {
        self.to_bytes()[..] == other.to_bytes()[..]
    }
}

impl Eq for WebAuthnP256Signature {}

impl fmt::Display for WebAuthnP256Signature {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", hex::encode(&self.to_bytes()[..]))
    }
}

impl fmt::Debug for WebAuthnP256Signature {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "WebAuthnP256Signature({})", self)
    }
}
